## 动态规划相关问题

什么是动态规划？
维基百科给的定义：将原问题拆解成若干子问题，在求解子问题的同时保存子问题的答案，使得每个子问题只求解一次，最终获得原问题的答案。（递归+记忆化搜索是符合该定义的！）

递归是自上而下的搜索。
动态规划一般是对递归的翻转，自下而上的推导。

```
                     |-->记忆化搜索（自顶向下地解决问题）  
递归问题-->重叠子问题--|
                     |-->动态规划（自底向上地解决问题）  
```  
                   
我们在解决问题的时候，自顶向下地思考是更容易的。所以在使用动态规划的时候，我们一般会先自顶向下地分析问题，然后再转换为自底向上的代码实现。
其实`递归+记忆化搜索`就等价于`动态规划`啦，它们的时间复杂度是一个量级的！

###### 问题509：斐波那契数

斐波那契数（通常用F(n)表示）形成的序列称为斐波那契数列。该数列由0和1开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。
示例 1：
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```java
public int fib(int n);
```                   

斐波那契数是典型的讲解`递归`、`递归+记忆化搜索`、`动态规划`的例题！
我们首先使用递归的方式做一遍：
```java
// 计算执行fib函数的次数
int count = 0;

public int fib(int n) {
    count++;
    if (n == 0 || n == 1) {
        return n;
    }
    return fib(n - 1) + fib(n - 2);
}
```
我们以求fib(5)为例，得到的count等于15。整个递归树如下图：

[斐波那契递归树](./img/09.dynamic-programming/q509_tree.png) 

如递归树所示，该递归存在大量的重复计算（重叠子问题）：
在计算fib(5)时需要计算fib(3)，计算fib(4)的时候也需要计算fib(3)；fib(2)也是如此，重复计算了很多遍......
算法的整体复杂度是O(2^n)。

我们可以使用记忆化搜索来对递归进行优化，将子问题的结果存入数组（或者哈希表）中，当重复计算子问题的时候，直接从数组（哈希表）中获取结果：
```java
// 计算执行fib函数的次数
int count = 0;

Map<Integer, Integer> memo = new HashMap<>();

public int fibMemo(int n) {
    count++;
    if (n == 0 || n == 1) {
        return n;
    }
    Integer res = memo.get(n);
    if (res == null) {
        res = fibMemo(n - 1) + fibMemo(n - 2);
        memo.put(n, res);
    }
    return res;
}
```
使用memo哈希表进行记忆化搜索以后，得到的count等于9（即2*n-1），算法整体复杂度来到了O(n)。只需要访问到如下的节点：

[斐波那契记忆化搜索](./img/09.dynamic-programming/q509_memo_tree.png)

再将记忆化搜索转换为动态规划的写法。由于fib(n)只和fib(n-1)、fib(n-2)有关，所以我们不需要存储全部子问题的结果，只需要存储前面两个子问题的结果：
```java
int count = 0;

/**
 * 斐波那契数列。动态规划
 *
 * @param n
 * @return
 */
public int fib(int n) {
    count++;
    if (n <= 1) {
        return n;
    }
    int beforeLast = 0;
    int last = 1;
    for (int i = 2; i <= n; i++) {
        int temp = beforeLast + last;
        beforeLast = last;
        last = temp;
    }
    return last;
}
```  
动态规划的代码会更简洁，是很优雅的算法！     

###### 问题70：climbing stairs

假设你正在爬楼梯。需要n阶你才能到达楼顶。
每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？
示例 1：
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```java
public int climbStairs(int n);
```

这题是动态规划的经典例题，我们采取自上而下的思考方式。
我们爬上楼顶的最后一步，可以走一个台阶或者两个台阶。如果是走了一个台阶，那么f(n)=f(n-1)；如果是走了两个台阶，那么f(n)=f(n-2)。

[爬楼梯递归树](./img/09.dynamic-programming/q70_tree.png)

综上，我们定义状态方程f(n)表示走上n阶台阶的不同方案数目，那么状态转移方程f(n)=f(n-1)+f(n-2)，其中f(1)=1，f(2)=2。
代码：
```java
public int climbStairs(int n) {
    int[] dp = new int[Math.max(n + 1, 3)];
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

9.3