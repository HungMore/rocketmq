## 贪心算法相关问题

通常来说，贪心算法的代码和思路会很简单。但是贪心算法真正的难点是，确定当前问题可以使用贪心算法来解决（局部最优解能决定全局最优解，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。）
贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

[贪心算法维基百科](https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95#)

> 贪心算法（英语：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。[1]比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。
> 贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。
> 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。
> 贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。在不同情况，选择最优的解，可能会导致[辛普森悖论](https://zh.wikipedia.org/wiki/%E8%BE%9B%E6%99%AE%E6%A3%AE%E6%82%96%E8%AE%BA)（Simpson's Paradox），不一定出现最优的解。
> 贪心算法在数据科学领域被广泛应用，特别是金融工程。其中一个贪心算法例子就是Ensemble method。
> [1] [曦辉, 邓. 浅谈贪心算法在排课系统中的应用](https://wenku.baidu.com/view/f177d2cc2cc58bd63186bd2d.html?_wkts_=1719971909054)

维基百科对贪心算法的介绍真的很棒，和动态规划的比较让人耳目一新！

###### 问题455：assign cookies

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子i，都有一个胃口值g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干j，都有一个尺寸s[j]。如果s[j]>=g[i]，我们可以将这个饼干j分配给孩子i，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
示例 1:
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
示例 2:
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
提示：
1 <= g.length <= 3 * 10^4
0 <= s.length <= 3 * 10^4
1 <= g[i], s[j] <= 231 - 1
```java
public int findContentChildren(int[] g, int[] s);
```

这题是很典型的贪心算法的例题！
思考下，对于一块饼干，肯定是尽量分配给它能满足的胃口最大的孩子最好。比如对于饼干3，它最好是分配给胃口为3的孩子，而不是1或者2的孩子，因为剩下的饼干很可能很小，应该让剩下的饼干可以尽可能地满足孩子胃口。如果饼干3分配给孩子1，那剩下的饼干1就没有用处了。所以算法思路：我们先将饼干s、胃口值g降序排序，然后“贪心”地将每一块饼干分给它所能满足的胃口最大的孩子，这样就能使得最多的孩子得到满足。
代码：
```java
public int findContentChildren(int[] g, int[] s) {
    int[] copyOfG = Arrays.copyOf(g, g.length);
    int[] copyOfS = Arrays.copyOf(s, s.length);
    Arrays.sort(copyOfG);
    Arrays.sort(copyOfS);
    int gCursor = copyOfG.length - 1, sCursor = copyOfS.length - 1;
    int res = 0;
    while (gCursor >= 0 && sCursor >= 0) {
        if (copyOfG[gCursor] <= copyOfS[sCursor]) {
            res++;
            sCursor--;
        }
        gCursor--;
    }
    return res;
}
```
贪心算法一般都涉及到取当前范围内的最大值或者最小值，所以一般都需要排序~

###### 问题392：is subsequence

给定字符串s和t，判断s是否为t的子序列。
字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
示例 1：
输入：s = "abc", t = "ahbgdc"
输出：true
示例 2：
输入：s = "axc", t = "ahbgdc"
输出：false
```java
public boolean isSubsequence(String s, String t);
```

对于这道题，我的第一想法是定义i\j两个指针分别指向s\t的最后一个字符，如果s[i]==t[j]，那么i--,j--；如果s[i]!=t[j]，那么j--。直至i等于-1或者j等于-1。如果i等于-1，返回true。
代码：
```java
public boolean isSubsequence(String s, String t) {
    int i = s.length() - 1, j = t.length() - 1;
    while (i >= 0 && j >= 0) {
        if (s.charAt(i) == t.charAt(j)) {
            i--;
            j--;
        } else {
            j--;
        }
    }
    return i == -1;
}
```
但是上面的解法是怎么归类到贪心算法上的呢？
其实很简单，对于s[i]==t[j]，我们直接i--,j--，就等价于“贪心”地把当前s[i]映射到t[j]上了。但是实际上，t[0...j-1]子串上可能还有很多个字符是等于s[i]的，我们也可以“不贪心”地将s[i]映射到的t[k]（k<j）上，但是这样完全没必要，我们越早完成对s[i]的映射，就冗余越多的t[k]供后续s[l]（l<i）选择。
所以在一些思路上，其实是有隐藏着贪心算法思想的，只是我们没有察觉到！

10.2